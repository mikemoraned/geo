# 2025

## January

* [x] show multiple sources at once (multiple cities)
    * [x] extract named `RegionSource` which has name of source and url, and `RegionGroup` which contains the resulting regions and an associated name
    * [x] switch to center map explicitly on a lat/lon as opposed to based on centroids (avoids having to choose one automatically)
    * [x] accept multiple sources and extract Regions from all of them
    * [x] switch the generation of GeoJSON for centroids to be done in Rust rather than JS (this is a pre-amble to doing same thing for Regions)
    * [x] display Regions which are union of Regions from all sources (using geojson generated by Rust)
    * [x] disable fetching of similar regions whilst flying between areas
    * [x] whilst still a bit slow, only show a subset of cities (edinburgh, paris)

* [x] cleanups and speedups
    * [x] optimise by:
        * [x] pregenerating where possible in domain layers
        * [x] passing geojson to JS as string, which is then parsed on JS side, as docs for wasm serde imply that as a lot of back-and-forth across the JS/WASM layer
    * [x] make domain layers clean of wasm-specific annotations
        * [x] move any console logging to use generate tracing/logging which is bridged to wasm console logging
    * [x] apply clippy lints


* [ ] blog post on recent changes
    * [x] blog post
    * [ ] add tags ability to blog
    * [ ] update linzer app to link back to "linzer" tag on blog

## February

* [ ] add hamburg
    * [x] make Justfile more generic
    * [x] separate `data` into `config` and `output` dirs
    * [ ] refactor: make `routing` crate repeatable and stable
        * [ ] ...
    * [ ] outstanding problem with running `just --set area hamburg --set profile auto all` (will solve later)

## March

* [ ] change `routing` to use OvertureMaps (OM) for definition of the city boundaries
  * [ ] check I can load OM data and use it
    * [x] load `division_area` into datafusion and count the rows
    * [ ] convert geometry column in WKB binary format into geo types
  * [ ] update bounding-box bounds of cities to be defined based on reading the city from OM
  * [ ] update random sampling to use actual city boundary
  * [ ] clamp routes to only those wholly contained within city shape
* [ ] filter out water areas
  * [ ] use water areas from OM as definition of holes in city shape

# Winter 2024 TODO's

## Linzer

* [x] update libs
    * [x] rustc version
    * [x] libs
        * [x] change all dependencies to be minor-only versions
        * [x] run `cargo update`
        * [x] run `cargo upgrade --compatible`
* [x] experiment: try different ways to summarise a shape in a normalised way which allows comparison across to similar shapes
    * [x] convert linzer web into a simple rust wasm app website
        * [x] create a basic Rust wasm monolithic module (not components) that says "hello world"
            - following https://dzfrias.dev/blog/rust-wasm-minimal-setup/#fn1
            * [x] install tools:
            ```
            cargo install wasm-pack
            ```
        * [x] deploy on netlify
            - build locally and just check in the wasm
            - deployed current branch `shape-experiment` to `https://linzer.netlify.app`
    * [x] show mapbox and georust working together:
        * [x] simple mapbox map in browser
            * [x] create a public mapbox key for use in netlify
                - restrict to use on https://linzer.netlify.app
                - called `geo-linzer-netlify`
            * [x] create a secret key for this app
                - will only be used locally
                - called `geo-linzer-local`
            * [x] create a `setting.js` module which defines `PUBLIC_MAPBOX_TOKEN` and maps to the secret key; this is not checked in
            * [x] define `PUBLIC_MAPBOX_TOKEN` in netlify
            * [x] update build so that takes a `setting.js.template` file and replaces `PUBLIC_MAPBOX_TOKEN` in it and saves in `setting.js`
        * [x] load a geojson source into map and show it
        * [x] load same geojson source from rust
        * [x] calculate centroids of each shape, using georust
        * [x] draw centroids in mapbox as a source
    * [x] usable UI for centroids
        * [x] ease of use: make each layer in mapbox toggleable on and off
        * [x] speed up / clean up: parse directly into geo-types, without using geojson intermediate step
        * [x] fix geometries: there appear to be a lot of 'degenerate' regions (very small). This really needs to be properly fixed upstream in the region generator, but for now we can probably filter these by size
        * [x] show spinner icon on layer buttons whilst waiting on layer to load
    * [x] show a set of 'rays' for each region
        - 'rays' are a set of linestrings for each region going from the centroid to each border-point
        * [x] refactor wasm into returning an `Annotated` object with a method for `centroids`
        * [x] add `rays` layer
    * [x] show a summary for each region
        - summary is the length of each ray as a fraction of max size of all rays for region
        * [-] visualise as a spiky shape per region in a CanvasSource
            * [x] add a canvas source covering area, displaying a test black rectangle covering entire area
            * [x] to confirm projection is working, draw centroids again on canvas as circles
                - this is sorta-maybe working but is fuzzy (as is a raster) and mapping seems still slightly-off
            * [-] show spikes as a series of arcs
        * [x] switch to layering D3 on top of the map, as in https://franksh.com/posts/d3-mapboxgl/, https://docs.os.uk/more-than-maps/tutorials/apis/d3-overlays-and-mapbox-gl
            * [x] remove previous canvas implementation
            * [x] load D3 and get it showing something minimal
            * [x] draw centroids using D3
            * [x] control display of centroids via top-control
        * [x] calculate summary
        * [x] show summary
    * [x] show a normalised summary for each region
        - a normalised summary is one where it has a fixed number of degrees and the length per a degree is a single number
        * [x] try:
            - degrees: 360
            - length: max length of all rays for each degree
            * [x] initially, don't worry about interpolating for degrees missing
            * [x] interpolation idea: as we iterate over pounts, ever time bearing changes by more than bucket size, 
            use `InterpolatePoint::point_at_ratio_between` to manufacture a series of points to fill the gaps
    * [x] create a "test card" for verifying projections and display
    * [x] refactor and optimise
        - split into a FooJS and Foo layer where Foo layer does the computations and FooJS binds those to types usable in JS
        - eagerly precalculate and store
        - remove dead code, including rays in the Rust RegionSummary
        - pull out JS into different modules
    * [x] find dominant directions of each shape based on summary
        * [x] try finding degree which maximises the sum of length at 0, 90, 180, 270 degree offset
    * [x] find similar shapes to current highlighted shape, based on summary
    * [x] make it easier to see how similar shapes are
        - try: visualise similar shapes as minimap or list at bottom
        * [x] fix up bugs in list
            * make it properly scrollable
            * don't let click on list propagate through
    * [x] expose at linzer.houseofmoran.io
        * [x] register CNAME domain entry and point at netlify
        * [x] expand `geo-linzer-netlify` mapbox key to work on https://linzer.houseofmoran.io
* [x] try shapes with edinburgh and other towns
    * [x] enable netlify PR builds
* [x] add plausible.io tracking for linzer.houseofmoran.io

## Geo

* [ ] convert top-level geo.houseofmoran.io site into a Zola blog
    * [x] switch to being deployed as github pages
    * [ ] use/create a simple blog template
    
# Geomob 2024

Things that I did for Geomob 2024 presentation

- [ ] minimal component parts:
    - [x] "biscuits" i.e. the parts of a city
        - ideas:
            - route-based
                1. Define a boundary
                2. Sample N locations within that boundary
                3. Find all routes between all pairs
                4. Restrict route lines by boundary
                5. Convert lines into pieces by converting to an image with lines and coalesce the pixels back into boundaries (re-purpose the garibaldi code)
                6. Project those boundaries back into geo shapes
            - road/way based
                1. Define a boundary
                2. Find all OS Ways (e.g. representing roads)
                3. Invert ...
                4. ...
        - impl:
            * [x] setup `houseofmoran-keks` property on stadiamaps
            * [x] get API key for `houseofmoran-keks`
            * [x] fetch route for a fixed pair of points and save as geojson
            * [x] vary routes by mode e.g. walking / cycling / driving
            * [x] fetch routes for N random pairs of points within a boundary and save as geojson
            * [x] make pairs have start/end points on the boundary (this ensures that paths always enclose an area)
            * [x] sample random pairs fairly across the area
                - e.g. sample random pairs of points over a grid
                - or https://www.jasondavies.com/poisson-disc/, https://docs.rs/fast_poisson/latest/fast_poisson/
            * [x] convert routes into pieces
                * [x] convert into black/white Luma image
                * [x] create a Justfile for repeatable recreation of everything
                * [x] find regions in image
                * [x] convert back into geojson
    - [x] layout:
        - [x] binpacking using https://lib.rs/crates/binpack2d
    - [ ] display:
        - [ ] convert to an SVG file with laid-out chunks in correct orientation

- things to add ahead of geomob presentation:
    - [ ] extend to cover a subset of the cities in the original http://www.armellecaron.fr/works/les-villes-rangees/
        - [x] make extraction of point sample grid a separate cli or sub-cli
        - [x] make sampling repeatable e.g. by taking an explicit seed
        - [x] make bounds of area cli args
        - [x] run for some sample cities
            - [x] edinburgh
            - [x] paris
            - [x] new york
            - [x] jerusalem
    - [x] regions:
        - [x] exclude boundary regions i.e. bits on the borders. these make the layouts typically very unbalanced
        - [x] exclude regions whose width, height, or area is > 20% of the respective width, height or area of whole bounding box
    - [x] make `geo.houseofmoran.io` a minimal static site with a blog post (or similar) pointing to slides
    - [x] rename `keks` to `linzer`
- things to fix later:
    - [ ] the random points created by a sample, using `Poisson2D`, are not always uniformly distributed across the rectangle (at least in the way I am using the library)
    - [ ] filter out water bodies as regions

- ideas:
    - turn the speed at which a route is travelled into a boundary property of the resulting shape e.g. if a route is travelled at a fast speed then shorten the length proportionally. this perhaps could be represented as the "springiness" of a bunch of line-segments. intent is to somehow represent the more transient nature of the experience of the area as a shortening or tension in the shape.